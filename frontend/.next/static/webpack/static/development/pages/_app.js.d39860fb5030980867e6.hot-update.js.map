{"version":3,"file":"static/webpack/static\\development\\pages\\_app.js.d39860fb5030980867e6.hot-update.js","sources":["webpack:///./components/Header.js","webpack:///./components/Search.js","webpack:///./components/styles/DropDown.js","webpack:///./node_modules/compute-scroll-into-view/es/index.js","webpack:///./node_modules/downshift/dist/downshift.esm.js","webpack:///./node_modules/lodash.debounce/index.js"],"sourcesContent":["import Nav from \"./Nav\";\r\nimport Link from \"next/link\";\r\nimport styled from \"styled-components\";\r\nimport Router from \"next/router\";\r\nimport NProgress from \"nprogress\";\r\nimport Cart from \"./Cart\";\r\nimport Search from \"./Search\";\r\n\r\nRouter.onRouteChangeStart = () => {\r\n  NProgress.start();\r\n};\r\nRouter.onRouteChangeComplete = () => {\r\n  NProgress.done();\r\n};\r\nRouter.onRouteChangeError = () => {\r\n  NProgress.done();\r\n};\r\n\r\nconst Logo = styled.h1`\r\n  font-size: 4rem;\r\n  margin-left: 2rem;\r\n  position: relative;\r\n  z-index: 2;\r\n  transform: skew(-7deg);\r\n  a {\r\n    padding: 0.5rem 1 rem;\r\n    background: ${(props) => props.theme.red};\r\n    color: white;\r\n    text-transform: uppercase;\r\n    text-decoration: none;\r\n  }\r\n  @media (max-width: 1300px) {\r\n    margin: 0;\r\n    text-align: center;\r\n  }\r\n`;\r\nconst StyledHeader = styled.header`\r\n  .bar {\r\n    border-bottom: 10px solid ${(props) => props.theme.black};\r\n    display: grid;\r\n    grid-template-columns: auto 1fr;\r\n    justify-content: space-between;\r\n    align-items: stretch;\r\n    @media (max-width: 1300px) {\r\n      grid-template-columns: 1fr;\r\n      justify-content: center;\r\n    }\r\n  }\r\n  .sub-bar {\r\n    display: grid;\r\n    grid-template-columns: 1fr auto;\r\n    border-bottom: 1px solid ${(props) => props.theme.lightgrey};\r\n  }\r\n`;\r\n\r\nconst Header = () => {\r\n  return (\r\n    <StyledHeader>\r\n      <div className=\"bar\">\r\n        <Logo>\r\n          <Link href=\"/\">\r\n            <a>Sick Fits</a>\r\n          </Link>\r\n        </Logo>\r\n      </div>\r\n      <Nav />\r\n      <div className=\"sub-bar\">\r\n        <p>Search</p>\r\n      </div>\r\n      <Cart />\r\n    </StyledHeader>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import React from \"react\";\r\nimport Downshift from \"downshift\";\r\nimport Router from \"next/router\";\r\nimport { ApolloConsumer } from \"react-apollo\";\r\nimport gql from \"graphql-tag\";\r\nimport debounce from \"lodash.debounce\";\r\nimport { DropDown, DropDownItem, SearchStyles } from \"./styles/DropDown\";\r\n\r\nclass AutoComplete extends React.Component {\r\n  render() {\r\n    return (\r\n      <SearchStyles>\r\n        <div>\r\n          <input type=\"search\" />\r\n          <DropDown>\r\n            <p>Items will go here</p>\r\n          </DropDown>\r\n        </div>\r\n      </SearchStyles>\r\n    );\r\n  }\r\n}\r\n\r\nexport default AutoComplete;\r\n","import styled, { keyframes } from 'styled-components';\r\n\r\nconst DropDown = styled.div`\r\n  position: absolute;\r\n  width: 100%;\r\n  z-index: 2;\r\n  border: 1px solid ${props => props.theme.lightgrey};\r\n`;\r\n\r\nconst DropDownItem = styled.div`\r\n  border-bottom: 1px solid ${props => props.theme.lightgrey};\r\n  background: ${props => (props.highlighted ? '#f7f7f7' : 'white')};\r\n  padding: 1rem;\r\n  transition: all 0.2s;\r\n  ${props => (props.highlighted ? 'padding-left: 2rem;' : null)};\r\n  display: flex;\r\n  align-items: center;\r\n  border-left: 10px solid ${props => (props.highlighted ? props.theme.lightgrey : 'white')};\r\n  img {\r\n    margin-right: 10px;\r\n  }\r\n`;\r\n\r\nconst glow = keyframes`\r\n  from {\r\n    box-shadow: 0 0 0px yellow;\r\n  }\r\n\r\n  to {\r\n    box-shadow: 0 0 10px 1px yellow;\r\n  }\r\n`;\r\n\r\nconst SearchStyles = styled.div`\r\n  position: relative;\r\n  input {\r\n    width: 100%;\r\n    padding: 10px;\r\n    border: 0;\r\n    font-size: 2rem;\r\n    &.loading {\r\n      animation: ${glow} 0.5s ease-in-out infinite alternate;\r\n    }\r\n  }\r\n`;\r\n\r\nexport { DropDown, DropDownItem, SearchStyles };\r\n","function isElement(el) {\r\n  return el != null && typeof el === 'object' && el.nodeType === 1;\r\n}\r\n\r\nfunction canOverflow(overflow, skipOverflowHiddenElements) {\r\n  if (skipOverflowHiddenElements && overflow === 'hidden') {\r\n    return false;\r\n  }\r\n\r\n  return overflow !== 'visible' && overflow !== 'clip';\r\n}\r\n\r\nfunction isScrollable(el, skipOverflowHiddenElements) {\r\n  if (el.clientHeight < el.scrollHeight || el.clientWidth < el.scrollWidth) {\r\n    var style = getComputedStyle(el, null);\r\n    return canOverflow(style.overflowY, skipOverflowHiddenElements) || canOverflow(style.overflowX, skipOverflowHiddenElements);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\r\n  if (elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd || elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd) {\r\n    return 0;\r\n  }\r\n\r\n  if (elementEdgeStart < scrollingEdgeStart && elementSize < scrollingSize || elementEdgeEnd > scrollingEdgeEnd && elementSize > scrollingSize) {\r\n    return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\r\n  }\r\n\r\n  if (elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize || elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize) {\r\n    return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nexport default (function (target, options) {\r\n  var scrollMode = options.scrollMode,\r\n      block = options.block,\r\n      inline = options.inline,\r\n      boundary = options.boundary,\r\n      skipOverflowHiddenElements = options.skipOverflowHiddenElements;\r\n  var checkBoundary = typeof boundary === 'function' ? boundary : function (node) {\r\n    return node !== boundary;\r\n  };\r\n\r\n  if (!isElement(target)) {\r\n    throw new TypeError('Invalid target');\r\n  }\r\n\r\n  var scrollingElement = document.scrollingElement || document.documentElement;\r\n  var frames = [];\r\n  var cursor = target;\r\n\r\n  while (isElement(cursor) && checkBoundary(cursor)) {\r\n    cursor = cursor.parentNode;\r\n\r\n    if (cursor === scrollingElement) {\r\n      frames.push(cursor);\r\n      break;\r\n    }\r\n\r\n    if (cursor === document.body && isScrollable(cursor) && !isScrollable(document.documentElement)) {\r\n      continue;\r\n    }\r\n\r\n    if (isScrollable(cursor, skipOverflowHiddenElements)) {\r\n      frames.push(cursor);\r\n    }\r\n  }\r\n\r\n  var viewportWidth = window.visualViewport ? visualViewport.width : innerWidth;\r\n  var viewportHeight = window.visualViewport ? visualViewport.height : innerHeight;\r\n  var viewportX = window.scrollX || pageXOffset;\r\n  var viewportY = window.scrollY || pageYOffset;\r\n\r\n  var _target$getBoundingCl = target.getBoundingClientRect(),\r\n      targetHeight = _target$getBoundingCl.height,\r\n      targetWidth = _target$getBoundingCl.width,\r\n      targetTop = _target$getBoundingCl.top,\r\n      targetRight = _target$getBoundingCl.right,\r\n      targetBottom = _target$getBoundingCl.bottom,\r\n      targetLeft = _target$getBoundingCl.left;\r\n\r\n  var targetBlock = block === 'start' || block === 'nearest' ? targetTop : block === 'end' ? targetBottom : targetTop + targetHeight / 2;\r\n  var targetInline = inline === 'center' ? targetLeft + targetWidth / 2 : inline === 'end' ? targetRight : targetLeft;\r\n  var computations = [];\r\n\r\n  for (var index = 0; index < frames.length; index++) {\r\n    var frame = frames[index];\r\n\r\n    var _frame$getBoundingCli = frame.getBoundingClientRect(),\r\n        _height = _frame$getBoundingCli.height,\r\n        _width = _frame$getBoundingCli.width,\r\n        _top = _frame$getBoundingCli.top,\r\n        right = _frame$getBoundingCli.right,\r\n        bottom = _frame$getBoundingCli.bottom,\r\n        _left = _frame$getBoundingCli.left;\r\n\r\n    if (scrollMode === 'if-needed' && targetTop >= 0 && targetLeft >= 0 && targetBottom <= viewportHeight && targetRight <= viewportWidth && targetTop >= _top && targetBottom <= bottom && targetLeft >= _left && targetRight <= right) {\r\n      return computations;\r\n    }\r\n\r\n    var frameStyle = getComputedStyle(frame);\r\n    var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\r\n    var borderTop = parseInt(frameStyle.borderTopWidth, 10);\r\n    var borderRight = parseInt(frameStyle.borderRightWidth, 10);\r\n    var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\r\n    var blockScroll = 0;\r\n    var inlineScroll = 0;\r\n    var scrollbarWidth = 'offsetWidth' in frame ? frame.offsetWidth - frame.clientWidth - borderLeft - borderRight : 0;\r\n    var scrollbarHeight = 'offsetHeight' in frame ? frame.offsetHeight - frame.clientHeight - borderTop - borderBottom : 0;\r\n\r\n    if (scrollingElement === frame) {\r\n      if (block === 'start') {\r\n        blockScroll = targetBlock;\r\n      } else if (block === 'end') {\r\n        blockScroll = targetBlock - viewportHeight;\r\n      } else if (block === 'nearest') {\r\n        blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\r\n      } else {\r\n        blockScroll = targetBlock - viewportHeight / 2;\r\n      }\r\n\r\n      if (inline === 'start') {\r\n        inlineScroll = targetInline;\r\n      } else if (inline === 'center') {\r\n        inlineScroll = targetInline - viewportWidth / 2;\r\n      } else if (inline === 'end') {\r\n        inlineScroll = targetInline - viewportWidth;\r\n      } else {\r\n        inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\r\n      }\r\n\r\n      blockScroll = Math.max(0, blockScroll + viewportY);\r\n      inlineScroll = Math.max(0, inlineScroll + viewportX);\r\n    } else {\r\n      if (block === 'start') {\r\n        blockScroll = targetBlock - _top - borderTop;\r\n      } else if (block === 'end') {\r\n        blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\r\n      } else if (block === 'nearest') {\r\n        blockScroll = alignNearest(_top, bottom, _height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\r\n      } else {\r\n        blockScroll = targetBlock - (_top + _height / 2) + scrollbarHeight / 2;\r\n      }\r\n\r\n      if (inline === 'start') {\r\n        inlineScroll = targetInline - _left - borderLeft;\r\n      } else if (inline === 'center') {\r\n        inlineScroll = targetInline - (_left + _width / 2) + scrollbarWidth / 2;\r\n      } else if (inline === 'end') {\r\n        inlineScroll = targetInline - right + borderRight + scrollbarWidth;\r\n      } else {\r\n        inlineScroll = alignNearest(_left, right, _width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\r\n      }\r\n\r\n      var scrollLeft = frame.scrollLeft,\r\n          scrollTop = frame.scrollTop;\r\n      blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, frame.scrollHeight - _height + scrollbarHeight));\r\n      inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, frame.scrollWidth - _width + scrollbarWidth));\r\n      targetBlock += scrollTop - blockScroll;\r\n      targetInline += scrollLeft - inlineScroll;\r\n    }\r\n\r\n    computations.push({\r\n      el: frame,\r\n      top: blockScroll,\r\n      left: inlineScroll\r\n    });\r\n  }\r\n\r\n  return computations;\r\n});","import computeScrollIntoView from 'compute-scroll-into-view';\r\nimport React, { Component } from 'react';\r\nimport PropTypes from 'prop-types';\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign || function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\nfunction _inheritsLoose(subClass, superClass) {\r\n  subClass.prototype = Object.create(superClass.prototype);\r\n  subClass.prototype.constructor = subClass;\r\n  subClass.__proto__ = superClass;\r\n}\r\n\r\nfunction _objectWithoutPropertiesLoose(source, excluded) {\r\n  if (source == null) return {};\r\n  var target = {};\r\n  var sourceKeys = Object.keys(source);\r\n  var key, i;\r\n\r\n  for (i = 0; i < sourceKeys.length; i++) {\r\n    key = sourceKeys[i];\r\n    if (excluded.indexOf(key) >= 0) continue;\r\n    target[key] = source[key];\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  if (self === void 0) {\r\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n  }\r\n\r\n  return self;\r\n}\r\n\r\n// istanbul ignore next\r\nvar statusDiv = typeof document === 'undefined' ? null : document.getElementById('a11y-status-message');\r\nvar statuses = [];\r\n/**\r\n * @param {String} status the status message\r\n */\r\n\r\nfunction setStatus(status) {\r\n  var isSameAsLast = statuses[statuses.length - 1] === status;\r\n\r\n  if (isSameAsLast) {\r\n    statuses = statuses.concat([status]);\r\n  } else {\r\n    statuses = [status];\r\n  }\r\n\r\n  var div = getStatusDiv(); // Remove previous children\r\n\r\n  while (div.lastChild) {\r\n    div.removeChild(div.firstChild);\r\n  }\r\n\r\n  statuses.filter(Boolean).forEach(function (statusItem, index) {\r\n    div.appendChild(getStatusChildDiv(statusItem, index));\r\n  });\r\n}\r\n/**\r\n * @param {String} status the status message\r\n * @param {Number} index the index\r\n * @return {HTMLElement} the child node\r\n */\r\n\r\n\r\nfunction getStatusChildDiv(status, index) {\r\n  var display = index === statuses.length - 1 ? 'block' : 'none';\r\n  var childDiv = document.createElement('div');\r\n  childDiv.style.display = display;\r\n  childDiv.textContent = status;\r\n  return childDiv;\r\n}\r\n/**\r\n * Get the status node or create it if it does not already exist\r\n * @return {HTMLElement} the status node\r\n */\r\n\r\n\r\nfunction getStatusDiv() {\r\n  if (statusDiv) {\r\n    return statusDiv;\r\n  }\r\n\r\n  statusDiv = document.createElement('div');\r\n  statusDiv.setAttribute('id', 'a11y-status-message');\r\n  statusDiv.setAttribute('role', 'status');\r\n  statusDiv.setAttribute('aria-live', 'assertive');\r\n  statusDiv.setAttribute('aria-relevant', 'additions text');\r\n  Object.assign(statusDiv.style, {\r\n    border: '0',\r\n    clip: 'rect(0 0 0 0)',\r\n    height: '1px',\r\n    margin: '-1px',\r\n    overflow: 'hidden',\r\n    padding: '0',\r\n    position: 'absolute',\r\n    width: '1px'\r\n  });\r\n  document.body.appendChild(statusDiv);\r\n  return statusDiv;\r\n}\r\n\r\nvar unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\r\nvar mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\r\nvar itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\r\nvar keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\r\nvar keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\r\nvar keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\r\nvar keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\r\nvar clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 7;\r\nvar blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 8;\r\nvar changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 9;\r\nvar keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 10;\r\nvar clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 11;\r\nvar blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 12;\r\nvar controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 13;\r\nvar touchStart = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchstart__' : 14;\r\n\r\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\r\n  unknown: unknown,\r\n  mouseUp: mouseUp,\r\n  itemMouseEnter: itemMouseEnter,\r\n  keyDownArrowUp: keyDownArrowUp,\r\n  keyDownArrowDown: keyDownArrowDown,\r\n  keyDownEscape: keyDownEscape,\r\n  keyDownEnter: keyDownEnter,\r\n  clickItem: clickItem,\r\n  blurInput: blurInput,\r\n  changeInput: changeInput,\r\n  keyDownSpaceButton: keyDownSpaceButton,\r\n  clickButton: clickButton,\r\n  blurButton: blurButton,\r\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\r\n  touchStart: touchStart\r\n});\r\n\r\nvar idCounter = 0;\r\n/**\r\n * Accepts a parameter and returns it if it's a function\r\n * or a noop function if it's not. This allows us to\r\n * accept a callback, but not worry about it if it's not\r\n * passed.\r\n * @param {Function} cb the callback\r\n * @return {Function} a function\r\n */\r\n\r\nfunction cbToCb(cb) {\r\n  return typeof cb === 'function' ? cb : noop;\r\n}\r\n\r\nfunction noop() {}\r\n/**\r\n * Scroll node into view if necessary\r\n * @param {HTMLElement} node the element that should scroll into view\r\n * @param {HTMLElement} rootNode the root element of the component\r\n */\r\n\r\n\r\nfunction scrollIntoView(node, rootNode) {\r\n  if (node === null) {\r\n    return;\r\n  }\r\n\r\n  var actions = computeScrollIntoView(node, {\r\n    boundary: rootNode,\r\n    block: 'nearest',\r\n    scrollMode: 'if-needed'\r\n  });\r\n  actions.forEach(function (_ref) {\r\n    var el = _ref.el,\r\n        top = _ref.top,\r\n        left = _ref.left;\r\n    el.scrollTop = top;\r\n    el.scrollLeft = left;\r\n  });\r\n}\r\n/**\r\n * @param {HTMLElement} parent the parent node\r\n * @param {HTMLElement} child the child node\r\n * @return {Boolean} whether the parent is the child or the child is in the parent\r\n */\r\n\r\n\r\nfunction isOrContainsNode(parent, child) {\r\n  return parent === child || parent.contains && parent.contains(child);\r\n}\r\n/**\r\n * Simple debounce implementation. Will call the given\r\n * function once after the time given has passed since\r\n * it was last called.\r\n * @param {Function} fn the function to call after the time\r\n * @param {Number} time the time to wait\r\n * @return {Function} the debounced function\r\n */\r\n\r\n\r\nfunction debounce(fn, time) {\r\n  var timeoutId;\r\n\r\n  function cancel() {\r\n    if (timeoutId) {\r\n      clearTimeout(timeoutId);\r\n    }\r\n  }\r\n\r\n  function wrapper() {\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    cancel();\r\n    timeoutId = setTimeout(function () {\r\n      timeoutId = null;\r\n      fn.apply(void 0, args);\r\n    }, time);\r\n  }\r\n\r\n  wrapper.cancel = cancel;\r\n  return wrapper;\r\n}\r\n/**\r\n * This is intended to be used to compose event handlers.\r\n * They are executed in order until one of them sets\r\n * `event.preventDownshiftDefault = true`.\r\n * @param {...Function} fns the event handler functions\r\n * @return {Function} the event handler to add to an element\r\n */\r\n\r\n\r\nfunction callAllEventHandlers() {\r\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n    fns[_key2] = arguments[_key2];\r\n  }\r\n\r\n  return function (event) {\r\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\r\n      args[_key3 - 1] = arguments[_key3];\r\n    }\r\n\r\n    return fns.some(function (fn) {\r\n      if (fn) {\r\n        fn.apply(void 0, [event].concat(args));\r\n      }\r\n\r\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\r\n    });\r\n  };\r\n}\r\n/**\r\n * This return a function that will call all the given functions with\r\n * the arguments with which it's called. It does a null-check before\r\n * attempting to call the functions and can take any number of functions.\r\n * @param {...Function} fns the functions to call\r\n * @return {Function} the function that calls all the functions\r\n */\r\n\r\n\r\nfunction callAll() {\r\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\r\n    fns[_key4] = arguments[_key4];\r\n  }\r\n\r\n  return function () {\r\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\r\n      args[_key5] = arguments[_key5];\r\n    }\r\n\r\n    fns.forEach(function (fn) {\r\n      if (fn) {\r\n        fn.apply(void 0, args);\r\n      }\r\n    });\r\n  };\r\n}\r\n/**\r\n * This generates a unique ID for an instance of Downshift\r\n * @return {String} the unique ID\r\n */\r\n\r\n\r\nfunction generateId() {\r\n  return String(idCounter++);\r\n}\r\n/**\r\n * Resets idCounter to 0. Used for SSR.\r\n */\r\n\r\n\r\nfunction resetIdCounter() {\r\n  idCounter = 0;\r\n}\r\n/**\r\n * @param {Object} param the downshift state and other relevant properties\r\n * @return {String} the a11y status message\r\n */\r\n\r\n\r\nfunction getA11yStatusMessage(_ref2) {\r\n  var isOpen = _ref2.isOpen,\r\n      highlightedItem = _ref2.highlightedItem,\r\n      selectedItem = _ref2.selectedItem,\r\n      resultCount = _ref2.resultCount,\r\n      previousResultCount = _ref2.previousResultCount,\r\n      itemToString = _ref2.itemToString;\r\n\r\n  if (!isOpen) {\r\n    if (selectedItem) {\r\n      return itemToString(selectedItem);\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  if (!resultCount) {\r\n    return 'No results.';\r\n  } else if (!highlightedItem || resultCount !== previousResultCount) {\r\n    return resultCount + \" \" + (resultCount === 1 ? 'result is' : 'results are') + \" available, use up and down arrow keys to navigate.\";\r\n  }\r\n\r\n  return itemToString(highlightedItem);\r\n}\r\n/**\r\n * Takes an argument and if it's an array, returns the first item in the array\r\n * otherwise returns the argument\r\n * @param {*} arg the maybe-array\r\n * @param {*} defaultValue the value if arg is falsey not defined\r\n * @return {*} the arg or it's first item\r\n */\r\n\r\n\r\nfunction unwrapArray(arg, defaultValue) {\r\n  arg = Array.isArray(arg) ?\r\n  /* istanbul ignore next (preact) */\r\n  arg[0] : arg;\r\n\r\n  if (!arg && defaultValue) {\r\n    return defaultValue;\r\n  } else {\r\n    return arg;\r\n  }\r\n}\r\n/**\r\n * @param {Object} element (P)react element\r\n * @return {Boolean} whether it's a DOM element\r\n */\r\n\r\n\r\nfunction isDOMElement(element) {\r\n  // then we assume this is react\r\n  return typeof element.type === 'string';\r\n}\r\n/**\r\n * @param {Object} element (P)react element\r\n * @return {Object} the props\r\n */\r\n\r\n\r\nfunction getElementProps(element) {\r\n  return element.props;\r\n}\r\n/**\r\n * Throws a helpful error message for required properties. Useful\r\n * to be used as a default in destructuring or object params.\r\n * @param {String} fnName the function name\r\n * @param {String} propName the prop name\r\n */\r\n\r\n\r\nfunction requiredProp(fnName, propName) {\r\n  // eslint-disable-next-line no-console\r\n  console.error(\"The property \\\"\" + propName + \"\\\" is required in \\\"\" + fnName + \"\\\"\");\r\n}\r\n\r\nvar stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\r\n/**\r\n * @param {Object} state the state object\r\n * @return {Object} state that is relevant to downshift\r\n */\r\n\r\nfunction pickState(state) {\r\n  if (state === void 0) {\r\n    state = {};\r\n  }\r\n\r\n  var result = {};\r\n  stateKeys.forEach(function (k) {\r\n    if (state.hasOwnProperty(k)) {\r\n      result[k] = state[k];\r\n    }\r\n  });\r\n  return result;\r\n}\r\n/**\r\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\r\n * @param {Object} event a keyboardEvent object\r\n * @return {String} keyboard key\r\n */\r\n\r\n\r\nfunction normalizeArrowKey(event) {\r\n  var key = event.key,\r\n      keyCode = event.keyCode;\r\n  /* istanbul ignore next (ie) */\r\n\r\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\r\n    return \"Arrow\" + key;\r\n  }\r\n\r\n  return key;\r\n}\r\n/**\r\n * Simple check if the value passed is object literal\r\n * @param {*} obj any things\r\n * @return {Boolean} whether it's object literal\r\n */\r\n\r\n\r\nfunction isPlainObject(obj) {\r\n  return Object.prototype.toString.call(obj) === '[object Object]';\r\n}\r\n\r\nvar Downshift =\r\n/*#__PURE__*/\r\nfunction (_Component) {\r\n  _inheritsLoose(Downshift, _Component);\r\n\r\n  function Downshift(_props) {\r\n    var _this = _Component.call(this, _props) || this;\r\n\r\n    _this.id = _this.props.id || \"downshift-\" + generateId();\r\n    _this.menuId = _this.props.menuId || _this.id + \"-menu\";\r\n    _this.labelId = _this.props.labelId || _this.id + \"-label\";\r\n    _this.inputId = _this.props.inputId || _this.id + \"-input\";\r\n\r\n    _this.getItemId = _this.props.getItemId || function (index) {\r\n      return _this.id + \"-item-\" + index;\r\n    };\r\n\r\n    _this.input = null;\r\n    _this.items = [];\r\n    _this.itemCount = null;\r\n    _this.previousResultCount = 0;\r\n    _this.timeoutIds = [];\r\n\r\n    _this.internalSetTimeout = function (fn, time) {\r\n      var id = setTimeout(function () {\r\n        _this.timeoutIds = _this.timeoutIds.filter(function (i) {\r\n          return i !== id;\r\n        });\r\n        fn();\r\n      }, time);\r\n\r\n      _this.timeoutIds.push(id);\r\n    };\r\n\r\n    _this.setItemCount = function (count) {\r\n      _this.itemCount = count;\r\n    };\r\n\r\n    _this.unsetItemCount = function () {\r\n      _this.itemCount = null;\r\n    };\r\n\r\n    _this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\r\n      if (highlightedIndex === void 0) {\r\n        highlightedIndex = _this.props.defaultHighlightedIndex;\r\n      }\r\n\r\n      if (otherStateToSet === void 0) {\r\n        otherStateToSet = {};\r\n      }\r\n\r\n      otherStateToSet = pickState(otherStateToSet);\r\n\r\n      _this.internalSetState(_extends({\r\n        highlightedIndex: highlightedIndex\r\n      }, otherStateToSet));\r\n    };\r\n\r\n    _this.clearSelection = function (cb) {\r\n      _this.internalSetState({\r\n        selectedItem: null,\r\n        inputValue: '',\r\n        isOpen: false\r\n      }, cb);\r\n    };\r\n\r\n    _this.selectItem = function (item, otherStateToSet, cb) {\r\n      otherStateToSet = pickState(otherStateToSet);\r\n\r\n      _this.internalSetState(_extends({\r\n        isOpen: false,\r\n        highlightedIndex: _this.props.defaultHighlightedIndex,\r\n        selectedItem: item,\r\n        inputValue: _this.isControlledProp('selectedItem') ? _this.props.defaultInputValue : _this.props.itemToString(item)\r\n      }, otherStateToSet), cb);\r\n    };\r\n\r\n    _this.selectItemAtIndex = function (itemIndex, otherStateToSet, cb) {\r\n      var item = _this.items[itemIndex];\r\n\r\n      if (item == null) {\r\n        return;\r\n      }\r\n\r\n      _this.selectItem(item, otherStateToSet, cb);\r\n    };\r\n\r\n    _this.selectHighlightedItem = function (otherStateToSet, cb) {\r\n      return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);\r\n    };\r\n\r\n    _this.internalSetState = function (stateToSet, cb) {\r\n      var isItemSelected, onChangeArg;\r\n      var onStateChangeArg = {};\r\n      var isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\r\n      // so someone controlling the `inputValue` state gets notified of\r\n      // the input change as soon as possible. This avoids issues with\r\n      // preserving the cursor position.\r\n      // See https://github.com/paypal/downshift/issues/217 for more info.\r\n\r\n      if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\r\n        _this.props.onInputValueChange(stateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), stateToSet));\r\n      }\r\n\r\n      return _this.setState(function (state) {\r\n        state = _this.getState(state);\r\n        var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\r\n\r\n        newStateToSet = _this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\r\n        // what was selected before\r\n        // used to determine if onSelect and onChange callbacks should be called\r\n\r\n        isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\r\n\r\n        var nextState = {}; // this is just used to tell whether the state changed\r\n\r\n        var nextFullState = {}; // we need to call on change if the outside world is controlling any of our state\r\n        // and we're trying to update that state. OR if the selection has changed and we're\r\n        // trying to update the selection\r\n\r\n        if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\r\n          onChangeArg = newStateToSet.selectedItem;\r\n        }\r\n\r\n        newStateToSet.type = newStateToSet.type || unknown;\r\n        Object.keys(newStateToSet).forEach(function (key) {\r\n          // onStateChangeArg should only have the state that is\r\n          // actually changing\r\n          if (state[key] !== newStateToSet[key]) {\r\n            onStateChangeArg[key] = newStateToSet[key];\r\n          } // the type is useful for the onStateChangeArg\r\n          // but we don't actually want to set it in internal state.\r\n          // this is an undocumented feature for now... Not all internalSetState\r\n          // calls support it and I'm not certain we want them to yet.\r\n          // But it enables users controlling the isOpen state to know when\r\n          // the isOpen state changes due to mouseup events which is quite handy.\r\n\r\n\r\n          if (key === 'type') {\r\n            return;\r\n          }\r\n\r\n          nextFullState[key] = newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\r\n\r\n          if (!_this.isControlledProp(key)) {\r\n            nextState[key] = newStateToSet[key];\r\n          }\r\n        }); // if stateToSet is a function, then we weren't able to call onInputValueChange\r\n        // earlier, so we'll call it now that we know what the inputValue state will be.\r\n\r\n        if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\r\n          _this.props.onInputValueChange(newStateToSet.inputValue, _extends({}, _this.getStateAndHelpers(), newStateToSet));\r\n        }\r\n\r\n        return nextState;\r\n      }, function () {\r\n        // call the provided callback if it's a function\r\n        cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\r\n        // we have relevant information to pass them.\r\n\r\n        var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\r\n\r\n        if (hasMoreStateThanType) {\r\n          _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());\r\n        }\r\n\r\n        if (isItemSelected) {\r\n          _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());\r\n        }\r\n\r\n        if (onChangeArg !== undefined) {\r\n          _this.props.onChange(onChangeArg, _this.getStateAndHelpers());\r\n        } // this is currently undocumented and therefore subject to change\r\n        // We'll try to not break it, but just be warned.\r\n\r\n\r\n        _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());\r\n      });\r\n    };\r\n\r\n    _this.rootRef = function (node) {\r\n      return _this._rootNode = node;\r\n    };\r\n\r\n    _this.getRootProps = function (_temp, _temp2) {\r\n      var _extends2;\r\n\r\n      var _ref = _temp === void 0 ? {} : _temp,\r\n          _ref$refKey = _ref.refKey,\r\n          refKey = _ref$refKey === void 0 ? 'ref' : _ref$refKey,\r\n          rest = _objectWithoutPropertiesLoose(_ref, [\"refKey\"]);\r\n\r\n      var _ref2 = _temp2 === void 0 ? {} : _temp2,\r\n          _ref2$suppressRefErro = _ref2.suppressRefError,\r\n          suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;\r\n\r\n      // this is used in the render to know whether the user has called getRootProps.\r\n      // It uses that to know whether to apply the props automatically\r\n      _this.getRootProps.called = true;\r\n      _this.getRootProps.refKey = refKey;\r\n      _this.getRootProps.suppressRefError = suppressRefError;\r\n\r\n      var _this$getState = _this.getState(),\r\n          isOpen = _this$getState.isOpen;\r\n\r\n      return _extends((_extends2 = {}, _extends2[refKey] = _this.rootRef, _extends2.role = 'combobox', _extends2['aria-expanded'] = isOpen, _extends2['aria-haspopup'] = 'listbox', _extends2['aria-owns'] = isOpen ? _this.menuId : null, _extends2['aria-labelledby'] = _this.labelId, _extends2), rest);\r\n    };\r\n\r\n    _this.keyDownHandlers = {\r\n      ArrowDown: function ArrowDown(event) {\r\n        event.preventDefault();\r\n        var amount = event.shiftKey ? 5 : 1;\r\n        this.moveHighlightedIndex(amount, {\r\n          type: keyDownArrowDown\r\n        });\r\n      },\r\n      ArrowUp: function ArrowUp(event) {\r\n        event.preventDefault();\r\n        var amount = event.shiftKey ? -5 : -1;\r\n        this.moveHighlightedIndex(amount, {\r\n          type: keyDownArrowUp\r\n        });\r\n      },\r\n      Enter: function Enter(event) {\r\n        var _this$getState2 = this.getState(),\r\n            isOpen = _this$getState2.isOpen,\r\n            highlightedIndex = _this$getState2.highlightedIndex;\r\n\r\n        if (isOpen && highlightedIndex != null) {\r\n          event.preventDefault();\r\n          var item = this.items[highlightedIndex];\r\n          var itemNode = this.getItemNodeFromIndex(highlightedIndex);\r\n\r\n          if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\r\n            return;\r\n          }\r\n\r\n          this.selectHighlightedItem({\r\n            type: keyDownEnter\r\n          });\r\n        }\r\n      },\r\n      Escape: function Escape(event) {\r\n        event.preventDefault();\r\n        this.reset({\r\n          type: keyDownEscape\r\n        });\r\n      }\r\n    };\r\n    _this.buttonKeyDownHandlers = _extends({}, _this.keyDownHandlers, {\r\n      ' ': function _(event) {\r\n        event.preventDefault();\r\n        this.toggleMenu({\r\n          type: keyDownSpaceButton\r\n        });\r\n      }\r\n    });\r\n\r\n    _this.getToggleButtonProps = function (_temp3) {\r\n      var _ref3 = _temp3 === void 0 ? {} : _temp3,\r\n          onClick = _ref3.onClick,\r\n          onPress = _ref3.onPress,\r\n          onKeyDown = _ref3.onKeyDown,\r\n          onKeyUp = _ref3.onKeyUp,\r\n          onBlur = _ref3.onBlur,\r\n          rest = _objectWithoutPropertiesLoose(_ref3, [\"onClick\", \"onPress\", \"onKeyDown\", \"onKeyUp\", \"onBlur\"]);\r\n\r\n      var _this$getState3 = _this.getState(),\r\n          isOpen = _this$getState3.isOpen;\r\n\r\n      var enabledEventHandlers = {\r\n        onClick: callAllEventHandlers(onClick, _this.button_handleClick),\r\n        onKeyDown: callAllEventHandlers(onKeyDown, _this.button_handleKeyDown),\r\n        onKeyUp: callAllEventHandlers(onKeyUp, _this.button_handleKeyUp),\r\n        onBlur: callAllEventHandlers(onBlur, _this.button_handleBlur)\r\n      };\r\n      var eventHandlers = rest.disabled ? {} : enabledEventHandlers;\r\n      return _extends({\r\n        type: 'button',\r\n        role: 'button',\r\n        'aria-label': isOpen ? 'close menu' : 'open menu',\r\n        'aria-haspopup': true,\r\n        'data-toggle': true\r\n      }, eventHandlers, rest);\r\n    };\r\n\r\n    _this.button_handleKeyUp = function (event) {\r\n      // Prevent click event from emitting in Firefox\r\n      event.preventDefault();\r\n    };\r\n\r\n    _this.button_handleKeyDown = function (event) {\r\n      var key = normalizeArrowKey(event);\r\n\r\n      if (_this.buttonKeyDownHandlers[key]) {\r\n        _this.buttonKeyDownHandlers[key].call(_assertThisInitialized(_assertThisInitialized(_this)), event);\r\n      }\r\n    };\r\n\r\n    _this.button_handleClick = function (event) {\r\n      event.preventDefault(); // handle odd case for Safari and Firefox which\r\n      // don't give the button the focus properly.\r\n\r\n      /* istanbul ignore if (can't reasonably test this) */\r\n\r\n      if (_this.props.environment.document.activeElement === _this.props.environment.document.body) {\r\n        event.target.focus();\r\n      } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\r\n      // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\r\n      // when building for production and should therefore have no impact on production code.\r\n\r\n\r\n      if (process.env.NODE_ENV === 'test') {\r\n        _this.toggleMenu({\r\n          type: clickButton\r\n        });\r\n      } else {\r\n        // Ensure that toggle of menu occurs after the potential blur event in iOS\r\n        _this.internalSetTimeout(function () {\r\n          return _this.toggleMenu({\r\n            type: clickButton\r\n          });\r\n        });\r\n      }\r\n    };\r\n\r\n    _this.button_handleBlur = function (event) {\r\n      var blurTarget = event.target; // Save blur target for comparison with activeElement later\r\n      // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\r\n\r\n      _this.internalSetTimeout(function () {\r\n        if (!_this.isMouseDown && (_this.props.environment.document.activeElement == null || _this.props.environment.document.activeElement.id !== _this.inputId) && _this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\r\n        ) {\r\n            _this.reset({\r\n              type: blurButton\r\n            });\r\n          }\r\n      });\r\n    };\r\n\r\n    _this.getLabelProps = function (props) {\r\n      return _extends({\r\n        htmlFor: _this.inputId,\r\n        id: _this.labelId\r\n      }, props);\r\n    };\r\n\r\n    _this.getInputProps = function (_temp4) {\r\n      var _ref4 = _temp4 === void 0 ? {} : _temp4,\r\n          onKeyDown = _ref4.onKeyDown,\r\n          onBlur = _ref4.onBlur,\r\n          onChange = _ref4.onChange,\r\n          onInput = _ref4.onInput,\r\n          onChangeText = _ref4.onChangeText,\r\n          rest = _objectWithoutPropertiesLoose(_ref4, [\"onKeyDown\", \"onBlur\", \"onChange\", \"onInput\", \"onChangeText\"]);\r\n\r\n      var onChangeKey;\r\n      var eventHandlers = {};\r\n      /* istanbul ignore next (preact) */\r\n\r\n      onChangeKey = 'onChange';\r\n\r\n      var _this$getState4 = _this.getState(),\r\n          inputValue = _this$getState4.inputValue,\r\n          isOpen = _this$getState4.isOpen,\r\n          highlightedIndex = _this$getState4.highlightedIndex;\r\n\r\n      if (!rest.disabled) {\r\n        var _eventHandlers;\r\n\r\n        eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.input_handleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.input_handleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.input_handleBlur), _eventHandlers);\r\n      }\r\n      /* istanbul ignore if (react-native) */\r\n\r\n\r\n      return _extends({\r\n        'aria-autocomplete': 'list',\r\n        'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\r\n        'aria-controls': isOpen ? _this.menuId : null,\r\n        'aria-labelledby': _this.labelId,\r\n        // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\r\n        // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\r\n        autoComplete: 'off',\r\n        value: inputValue,\r\n        id: _this.inputId\r\n      }, eventHandlers, rest);\r\n    };\r\n\r\n    _this.input_handleKeyDown = function (event) {\r\n      var key = normalizeArrowKey(event);\r\n\r\n      if (key && _this.keyDownHandlers[key]) {\r\n        _this.keyDownHandlers[key].call(_assertThisInitialized(_assertThisInitialized(_this)), event);\r\n      }\r\n    };\r\n\r\n    _this.input_handleChange = function (event) {\r\n      _this.internalSetState({\r\n        type: changeInput,\r\n        isOpen: true,\r\n        inputValue: event.target.value\r\n      });\r\n    };\r\n\r\n    _this.input_handleTextChange\r\n    /* istanbul ignore next (react-native) */\r\n    = function (text) {\r\n      _this.internalSetState({\r\n        type: changeInput,\r\n        isOpen: true,\r\n        inputValue: text\r\n      });\r\n    };\r\n\r\n    _this.input_handleBlur = function () {\r\n      // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\r\n      _this.internalSetTimeout(function () {\r\n        var downshiftButtonIsActive = _this.props.environment.document && _this.props.environment.document.activeElement.dataset.toggle && _this._rootNode && _this._rootNode.contains(_this.props.environment.document.activeElement);\r\n\r\n        if (!_this.isMouseDown && !downshiftButtonIsActive) {\r\n          _this.reset({\r\n            type: blurInput\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    _this.menuRef = function (node) {\r\n      _this._menuNode = node;\r\n    };\r\n\r\n    _this.getMenuProps = function (_temp5, _temp6) {\r\n      var _extends3;\r\n\r\n      var _ref5 = _temp5 === void 0 ? {} : _temp5,\r\n          _ref5$refKey = _ref5.refKey,\r\n          refKey = _ref5$refKey === void 0 ? 'ref' : _ref5$refKey,\r\n          ref = _ref5.ref,\r\n          props = _objectWithoutPropertiesLoose(_ref5, [\"refKey\", \"ref\"]);\r\n\r\n      var _ref6 = _temp6 === void 0 ? {} : _temp6,\r\n          _ref6$suppressRefErro = _ref6.suppressRefError,\r\n          suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;\r\n\r\n      _this.getMenuProps.called = true;\r\n      _this.getMenuProps.refKey = refKey;\r\n      _this.getMenuProps.suppressRefError = suppressRefError;\r\n      return _extends((_extends3 = {}, _extends3[refKey] = callAll(ref, _this.menuRef), _extends3.role = 'listbox', _extends3['aria-labelledby'] = props && props['aria-label'] ? null : _this.labelId, _extends3.id = _this.menuId, _extends3), props);\r\n    };\r\n\r\n    _this.getItemProps = function (_temp7) {\r\n      var _enabledEventHandlers;\r\n\r\n      var _ref7 = _temp7 === void 0 ? {} : _temp7,\r\n          onMouseMove = _ref7.onMouseMove,\r\n          onMouseDown = _ref7.onMouseDown,\r\n          onClick = _ref7.onClick,\r\n          onPress = _ref7.onPress,\r\n          index = _ref7.index,\r\n          _ref7$item = _ref7.item,\r\n          item = _ref7$item === void 0 ? process.env.NODE_ENV === 'production' ?\r\n      /* istanbul ignore next */\r\n      undefined : requiredProp('getItemProps', 'item') : _ref7$item,\r\n          rest = _objectWithoutPropertiesLoose(_ref7, [\"onMouseMove\", \"onMouseDown\", \"onClick\", \"onPress\", \"index\", \"item\"]);\r\n\r\n      if (index === undefined) {\r\n        _this.items.push(item);\r\n\r\n        index = _this.items.indexOf(item);\r\n      } else {\r\n        _this.items[index] = item;\r\n      }\r\n\r\n      var onSelectKey = 'onClick';\r\n      var customClickHandler = onClick;\r\n      var enabledEventHandlers = (_enabledEventHandlers = {\r\n        // onMouseMove is used over onMouseEnter here. onMouseMove\r\n        // is only triggered on actual mouse movement while onMouseEnter\r\n        // can fire on DOM changes, interrupting keyboard navigation\r\n        onMouseMove: callAllEventHandlers(onMouseMove, function () {\r\n          if (index === _this.getState().highlightedIndex) {\r\n            return;\r\n          }\r\n\r\n          _this.setHighlightedIndex(index, {\r\n            type: itemMouseEnter\r\n          }); // We never want to manually scroll when changing state based\r\n          // on `onMouseMove` because we will be moving the element out\r\n          // from under the user which is currently scrolling/moving the\r\n          // cursor\r\n\r\n\r\n          _this.avoidScrolling = true;\r\n\r\n          _this.internalSetTimeout(function () {\r\n            return _this.avoidScrolling = false;\r\n          }, 250);\r\n        }),\r\n        onMouseDown: callAllEventHandlers(onMouseDown, function (event) {\r\n          // This prevents the activeElement from being changed\r\n          // to the item so it can remain with the current activeElement\r\n          // which is a more common use case.\r\n          event.preventDefault();\r\n        })\r\n      }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function () {\r\n        _this.selectItemAtIndex(index, {\r\n          type: clickItem\r\n        });\r\n      }), _enabledEventHandlers); // Passing down the onMouseDown handler to prevent redirect\r\n      // of the activeElement if clicking on disabled items\r\n\r\n      var eventHandlers = rest.disabled ? {\r\n        onMouseDown: enabledEventHandlers.onMouseDown\r\n      } : enabledEventHandlers;\r\n      return _extends({\r\n        id: _this.getItemId(index),\r\n        role: 'option',\r\n        'aria-selected': _this.getState().selectedItem === item\r\n      }, eventHandlers, rest);\r\n    };\r\n\r\n    _this.clearItems = function () {\r\n      _this.items = [];\r\n    };\r\n\r\n    _this.reset = function (otherStateToSet, cb) {\r\n      if (otherStateToSet === void 0) {\r\n        otherStateToSet = {};\r\n      }\r\n\r\n      otherStateToSet = pickState(otherStateToSet);\r\n\r\n      _this.internalSetState(function (_ref8) {\r\n        var selectedItem = _ref8.selectedItem;\r\n        return _extends({\r\n          isOpen: false,\r\n          highlightedIndex: _this.props.defaultHighlightedIndex,\r\n          inputValue: _this.props.itemToString(selectedItem)\r\n        }, otherStateToSet);\r\n      }, cb);\r\n    };\r\n\r\n    _this.toggleMenu = function (otherStateToSet, cb) {\r\n      if (otherStateToSet === void 0) {\r\n        otherStateToSet = {};\r\n      }\r\n\r\n      otherStateToSet = pickState(otherStateToSet);\r\n\r\n      _this.internalSetState(function (_ref9) {\r\n        var isOpen = _ref9.isOpen;\r\n        return _extends({\r\n          isOpen: !isOpen\r\n        }, otherStateToSet);\r\n      }, function () {\r\n        var _this$getState5 = _this.getState(),\r\n            isOpen = _this$getState5.isOpen;\r\n\r\n        if (isOpen) {\r\n          // highlight default index\r\n          _this.setHighlightedIndex(undefined, otherStateToSet);\r\n        }\r\n\r\n        cbToCb(cb)();\r\n      });\r\n    };\r\n\r\n    _this.openMenu = function (cb) {\r\n      _this.internalSetState({\r\n        isOpen: true\r\n      }, cb);\r\n    };\r\n\r\n    _this.closeMenu = function (cb) {\r\n      _this.internalSetState({\r\n        isOpen: false\r\n      }, cb);\r\n    };\r\n\r\n    _this.updateStatus = debounce(function () {\r\n      var state = _this.getState();\r\n\r\n      var item = _this.items[state.highlightedIndex];\r\n\r\n      var resultCount = _this.getItemCount();\r\n\r\n      var status = _this.props.getA11yStatusMessage(_extends({\r\n        itemToString: _this.props.itemToString,\r\n        previousResultCount: _this.previousResultCount,\r\n        resultCount: resultCount,\r\n        highlightedItem: item\r\n      }, state));\r\n\r\n      _this.previousResultCount = resultCount;\r\n      setStatus(status);\r\n    }, 200);\r\n\r\n    var _state = _this.getState({\r\n      highlightedIndex: _this.props.defaultHighlightedIndex,\r\n      isOpen: _this.props.defaultIsOpen,\r\n      inputValue: _this.props.defaultInputValue,\r\n      selectedItem: _this.props.defaultSelectedItem\r\n    });\r\n\r\n    if (_state.selectedItem != null) {\r\n      _state.inputValue = _this.props.itemToString(_state.selectedItem);\r\n    }\r\n\r\n    _this.state = _state;\r\n    return _this;\r\n  }\r\n\r\n  var _proto = Downshift.prototype;\r\n\r\n  /**\r\n   * Clear all running timeouts\r\n   */\r\n  _proto.internalClearTimeouts = function internalClearTimeouts() {\r\n    this.timeoutIds.forEach(function (id) {\r\n      clearTimeout(id);\r\n    });\r\n    this.timeoutIds = [];\r\n  };\r\n  /**\r\n   * Gets the state based on internal state or props\r\n   * If a state value is passed via props, then that\r\n   * is the value given, otherwise it's retrieved from\r\n   * stateToMerge\r\n   *\r\n   * This will perform a shallow merge of the given state object\r\n   * with the state coming from props\r\n   * (for the controlled component scenario)\r\n   * This is used in state updater functions so they're referencing\r\n   * the right state regardless of where it comes from.\r\n   *\r\n   * @param {Object} stateToMerge defaults to this.state\r\n   * @return {Object} the state\r\n   */\r\n\r\n\r\n  _proto.getState = function getState(stateToMerge) {\r\n    var _this2 = this;\r\n\r\n    if (stateToMerge === void 0) {\r\n      stateToMerge = this.state;\r\n    }\r\n\r\n    return Object.keys(stateToMerge).reduce(function (state, key) {\r\n      state[key] = _this2.isControlledProp(key) ? _this2.props[key] : stateToMerge[key];\r\n      return state;\r\n    }, {});\r\n  };\r\n  /**\r\n   * This determines whether a prop is a \"controlled prop\" meaning it is\r\n   * state which is controlled by the outside of this component rather\r\n   * than within this component.\r\n   * @param {String} key the key to check\r\n   * @return {Boolean} whether it is a controlled controlled prop\r\n   */\r\n\r\n\r\n  _proto.isControlledProp = function isControlledProp(key) {\r\n    return this.props[key] !== undefined;\r\n  };\r\n\r\n  _proto.getItemCount = function getItemCount() {\r\n    // things read better this way. They're in priority order:\r\n    // 1. `this.itemCount`\r\n    // 2. `this.props.itemCount`\r\n    // 3. `this.items.length`\r\n    var itemCount = this.items.length;\r\n\r\n    if (this.itemCount != null) {\r\n      itemCount = this.itemCount;\r\n    } else if (this.props.itemCount !== undefined) {\r\n      itemCount = this.props.itemCount;\r\n    }\r\n\r\n    return itemCount;\r\n  };\r\n\r\n  _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index) {\r\n    return this.props.environment.document.getElementById(this.getItemId(index));\r\n  };\r\n\r\n  _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {\r\n    /* istanbul ignore else (react-native) */\r\n    {\r\n      var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\r\n      this.props.scrollIntoView(node, this._rootNode);\r\n    }\r\n  };\r\n\r\n  _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {\r\n    if (this.getState().isOpen) {\r\n      this.changeHighlightedIndex(amount, otherStateToSet);\r\n    } else {\r\n      this.setHighlightedIndex(undefined, _extends({\r\n        isOpen: true\r\n      }, otherStateToSet));\r\n    }\r\n  };\r\n\r\n  _proto.changeHighlightedIndex = function changeHighlightedIndex(moveAmount, otherStateToSet) {\r\n    var itemsLastIndex = this.getItemCount() - 1;\r\n\r\n    if (itemsLastIndex < 0) {\r\n      return;\r\n    }\r\n\r\n    var _this$getState6 = this.getState(),\r\n        highlightedIndex = _this$getState6.highlightedIndex;\r\n\r\n    var baseIndex = highlightedIndex;\r\n\r\n    if (baseIndex === null) {\r\n      baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\r\n    }\r\n\r\n    var newIndex = baseIndex + moveAmount;\r\n\r\n    if (newIndex < 0) {\r\n      newIndex = itemsLastIndex;\r\n    } else if (newIndex > itemsLastIndex) {\r\n      newIndex = 0;\r\n    }\r\n\r\n    this.setHighlightedIndex(newIndex, otherStateToSet);\r\n  };\r\n\r\n  _proto.getStateAndHelpers = function getStateAndHelpers() {\r\n    var _this$getState7 = this.getState(),\r\n        highlightedIndex = _this$getState7.highlightedIndex,\r\n        inputValue = _this$getState7.inputValue,\r\n        selectedItem = _this$getState7.selectedItem,\r\n        isOpen = _this$getState7.isOpen;\r\n\r\n    var itemToString = this.props.itemToString;\r\n    var id = this.id;\r\n    var getRootProps = this.getRootProps,\r\n        getToggleButtonProps = this.getToggleButtonProps,\r\n        getLabelProps = this.getLabelProps,\r\n        getMenuProps = this.getMenuProps,\r\n        getInputProps = this.getInputProps,\r\n        getItemProps = this.getItemProps,\r\n        openMenu = this.openMenu,\r\n        closeMenu = this.closeMenu,\r\n        toggleMenu = this.toggleMenu,\r\n        selectItem = this.selectItem,\r\n        selectItemAtIndex = this.selectItemAtIndex,\r\n        selectHighlightedItem = this.selectHighlightedItem,\r\n        setHighlightedIndex = this.setHighlightedIndex,\r\n        clearSelection = this.clearSelection,\r\n        clearItems = this.clearItems,\r\n        reset = this.reset,\r\n        setItemCount = this.setItemCount,\r\n        unsetItemCount = this.unsetItemCount,\r\n        setState = this.internalSetState;\r\n    return {\r\n      // prop getters\r\n      getRootProps: getRootProps,\r\n      getToggleButtonProps: getToggleButtonProps,\r\n      getLabelProps: getLabelProps,\r\n      getMenuProps: getMenuProps,\r\n      getInputProps: getInputProps,\r\n      getItemProps: getItemProps,\r\n      // actions\r\n      reset: reset,\r\n      openMenu: openMenu,\r\n      closeMenu: closeMenu,\r\n      toggleMenu: toggleMenu,\r\n      selectItem: selectItem,\r\n      selectItemAtIndex: selectItemAtIndex,\r\n      selectHighlightedItem: selectHighlightedItem,\r\n      setHighlightedIndex: setHighlightedIndex,\r\n      clearSelection: clearSelection,\r\n      clearItems: clearItems,\r\n      setItemCount: setItemCount,\r\n      unsetItemCount: unsetItemCount,\r\n      setState: setState,\r\n      // props\r\n      itemToString: itemToString,\r\n      // derived\r\n      id: id,\r\n      // state\r\n      highlightedIndex: highlightedIndex,\r\n      inputValue: inputValue,\r\n      isOpen: isOpen,\r\n      selectedItem: selectedItem\r\n    };\r\n  }; //////////////////////////// ROOT\r\n\r\n\r\n  _proto.componentDidMount = function componentDidMount() {\r\n    var _this3 = this;\r\n\r\n    /* istanbul ignore if (react-native) */\r\n    if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\r\n      validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\r\n    }\r\n    /* istanbul ignore if (react-native) */\r\n\r\n\r\n    {\r\n      var targetWithinDownshift = function (target, checkActiveElement) {\r\n        if (checkActiveElement === void 0) {\r\n          checkActiveElement = true;\r\n        }\r\n\r\n        var document = _this3.props.environment.document;\r\n        return [_this3._rootNode, _this3._menuNode].some(function (contextNode) {\r\n          return contextNode && (isOrContainsNode(contextNode, target) || checkActiveElement && isOrContainsNode(contextNode, document.activeElement));\r\n        });\r\n      }; // this.isMouseDown helps us track whether the mouse is currently held down.\r\n      // This is useful when the user clicks on an item in the list, but holds the mouse\r\n      // down long enough for the list to disappear (because the blur event fires on the input)\r\n      // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\r\n      // trigger hiding the menu.\r\n\r\n\r\n      var onMouseDown = function () {\r\n        _this3.isMouseDown = true;\r\n      };\r\n\r\n      var onMouseUp = function (event) {\r\n        _this3.isMouseDown = false; // if the target element or the activeElement is within a downshift node\r\n        // then we don't want to reset downshift\r\n\r\n        var contextWithinDownshift = targetWithinDownshift(event.target);\r\n\r\n        if (!contextWithinDownshift && _this3.getState().isOpen) {\r\n          _this3.reset({\r\n            type: mouseUp\r\n          }, function () {\r\n            return _this3.props.onOuterClick(_this3.getStateAndHelpers());\r\n          });\r\n        }\r\n      }; // Touching an element in iOS gives focus and hover states, but touching out of\r\n      // the element will remove hover, and persist the focus state, resulting in the\r\n      // blur event not being triggered.\r\n\r\n\r\n      var onTouchStart = function (event) {\r\n        var contextWithinDownshift = targetWithinDownshift(event.target, false);\r\n\r\n        if (!contextWithinDownshift && _this3.getState().isOpen) {\r\n          _this3.reset({\r\n            type: touchStart\r\n          }, function () {\r\n            return _this3.props.onOuterClick(_this3.getStateAndHelpers());\r\n          });\r\n        }\r\n      };\r\n\r\n      this.props.environment.addEventListener('mousedown', onMouseDown);\r\n      this.props.environment.addEventListener('mouseup', onMouseUp);\r\n      this.props.environment.addEventListener('touchstart', onTouchStart);\r\n\r\n      this.cleanup = function () {\r\n        _this3.internalClearTimeouts();\r\n\r\n        _this3.updateStatus.cancel();\r\n\r\n        _this3.props.environment.removeEventListener('mousedown', onMouseDown);\r\n\r\n        _this3.props.environment.removeEventListener('mouseup', onMouseUp);\r\n\r\n        _this3.props.environment.removeEventListener('touchstart', onTouchStart);\r\n      };\r\n    }\r\n  };\r\n\r\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      validateControlledUnchanged(prevProps, this.props);\r\n      /* istanbul ignore if (react-native) */\r\n\r\n      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\r\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\r\n      }\r\n    }\r\n\r\n    if (this.isControlledProp('selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\r\n      this.internalSetState({\r\n        type: controlledPropUpdatedSelectedItem,\r\n        inputValue: this.props.itemToString(this.props.selectedItem)\r\n      });\r\n    }\r\n\r\n    var current = this.props.highlightedIndex === undefined ? this.state : this.props;\r\n    var prev = prevProps.highlightedIndex === undefined ? prevState : prevProps;\r\n\r\n    if (current.highlightedIndex !== prev.highlightedIndex && !this.avoidScrolling) {\r\n      this.scrollHighlightedItemIntoView();\r\n    }\r\n    /* istanbul ignore else (react-native) */\r\n\r\n\r\n    this.updateStatus();\r\n  };\r\n\r\n  _proto.componentWillUnmount = function componentWillUnmount() {\r\n    this.cleanup(); // avoids memory leak\r\n  };\r\n\r\n  _proto.render = function render() {\r\n    var children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\r\n    // we clear this out each render and it will be populated again as\r\n    // getItemProps is called.\r\n\r\n    this.clearItems(); // we reset this so we know whether the user calls getRootProps during\r\n    // this render. If they do then we don't need to do anything,\r\n    // if they don't then we need to clone the element they return and\r\n    // apply the props for them.\r\n\r\n    this.getRootProps.called = false;\r\n    this.getRootProps.refKey = undefined;\r\n    this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\r\n\r\n    this.getMenuProps.called = false;\r\n    this.getMenuProps.refKey = undefined;\r\n    this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\r\n\r\n    this.getLabelProps.called = false; // and something similar for getInputProps\r\n\r\n    this.getInputProps.called = false;\r\n    var element = unwrapArray(children(this.getStateAndHelpers()));\r\n\r\n    if (!element) {\r\n      return null;\r\n    }\r\n\r\n    if (this.getRootProps.called || this.props.suppressRefError) {\r\n      if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\r\n        validateGetRootPropsCalledCorrectly(element, this.getRootProps);\r\n      }\r\n\r\n      return element;\r\n    } else if (isDOMElement(element)) {\r\n      // they didn't apply the root props, but we can clone\r\n      // this and apply the props ourselves\r\n      return React.cloneElement(element, this.getRootProps(getElementProps(element)));\r\n    }\r\n    /* istanbul ignore else */\r\n\r\n\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // they didn't apply the root props, but they need to\r\n      // otherwise we can't query around the autocomplete\r\n      throw new Error('downshift: If you return a non-DOM element, you must use apply the getRootProps function');\r\n    }\r\n    /* istanbul ignore next */\r\n\r\n\r\n    return undefined;\r\n  };\r\n\r\n  return Downshift;\r\n}(Component);\r\n\r\nDownshift.defaultProps = {\r\n  defaultHighlightedIndex: null,\r\n  defaultSelectedItem: null,\r\n  defaultInputValue: '',\r\n  defaultIsOpen: false,\r\n  getA11yStatusMessage: getA11yStatusMessage,\r\n  itemToString: function itemToString(i) {\r\n    if (i == null) {\r\n      return '';\r\n    }\r\n\r\n    if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\r\n      // eslint-disable-next-line no-console\r\n      console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\r\n    }\r\n\r\n    return String(i);\r\n  },\r\n  onStateChange: noop,\r\n  onInputValueChange: noop,\r\n  onUserAction: noop,\r\n  onChange: noop,\r\n  onSelect: noop,\r\n  onOuterClick: noop,\r\n  selectedItemChanged: function selectedItemChanged(prevItem, item) {\r\n    return prevItem !== item;\r\n  },\r\n  environment: typeof window === 'undefined'\r\n  /* istanbul ignore next (ssr) */\r\n  ? {} : window,\r\n  stateReducer: function stateReducer(state, stateToSet) {\r\n    return stateToSet;\r\n  },\r\n  suppressRefError: false,\r\n  scrollIntoView: scrollIntoView\r\n};\r\nDownshift.stateChangeTypes = stateChangeTypes;\r\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\r\n  children: PropTypes.func,\r\n  defaultHighlightedIndex: PropTypes.number,\r\n  defaultSelectedItem: PropTypes.any,\r\n  defaultInputValue: PropTypes.string,\r\n  defaultIsOpen: PropTypes.bool,\r\n  getA11yStatusMessage: PropTypes.func,\r\n  itemToString: PropTypes.func,\r\n  onChange: PropTypes.func,\r\n  onSelect: PropTypes.func,\r\n  onStateChange: PropTypes.func,\r\n  onInputValueChange: PropTypes.func,\r\n  onUserAction: PropTypes.func,\r\n  onOuterClick: PropTypes.func,\r\n  selectedItemChanged: PropTypes.func,\r\n  stateReducer: PropTypes.func,\r\n  itemCount: PropTypes.number,\r\n  id: PropTypes.string,\r\n  environment: PropTypes.shape({\r\n    addEventListener: PropTypes.func,\r\n    removeEventListener: PropTypes.func,\r\n    document: PropTypes.shape({\r\n      getElementById: PropTypes.func,\r\n      activeElement: PropTypes.any,\r\n      body: PropTypes.any\r\n    })\r\n  }),\r\n  suppressRefError: PropTypes.bool,\r\n  scrollIntoView: PropTypes.func,\r\n  // things we keep in state for uncontrolled components\r\n  // but can accept as props for controlled components\r\n\r\n  /* eslint-disable react/no-unused-prop-types */\r\n  selectedItem: PropTypes.any,\r\n  isOpen: PropTypes.bool,\r\n  inputValue: PropTypes.string,\r\n  highlightedIndex: PropTypes.number,\r\n  labelId: PropTypes.string,\r\n  inputId: PropTypes.string,\r\n  menuId: PropTypes.string,\r\n  getItemId: PropTypes.func\r\n  /* eslint-enable react/no-unused-prop-types */\r\n\r\n} : void 0;\r\n\r\nfunction validateGetMenuPropsCalledCorrectly(node, _ref10) {\r\n  var refKey = _ref10.refKey;\r\n\r\n  if (!node) {\r\n    // eslint-disable-next-line no-console\r\n    console.error(\"downshift: The ref prop \\\"\" + refKey + \"\\\" from getMenuProps was not applied correctly on your menu element.\");\r\n  }\r\n}\r\n\r\nfunction validateGetRootPropsCalledCorrectly(element, _ref11) {\r\n  var refKey = _ref11.refKey;\r\n  var refKeySpecified = refKey !== 'ref';\r\n  var isComposite = !isDOMElement(element);\r\n\r\n  if (isComposite && !refKeySpecified) {\r\n    // eslint-disable-next-line no-console\r\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\r\n  } else if (!isComposite && refKeySpecified) {\r\n    // eslint-disable-next-line no-console\r\n    console.error(\"downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \\\"\" + refKey + \"\\\"\");\r\n  }\r\n\r\n  if (!getElementProps(element)[refKey]) {\r\n    // eslint-disable-next-line no-console\r\n    console.error(\"downshift: You must apply the ref prop \\\"\" + refKey + \"\\\" from getRootProps onto your root element.\");\r\n  }\r\n}\r\n\r\nfunction validateControlledUnchanged(prevProps, nextProps) {\r\n  var warningDescription = \"This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/paypal/downshift#control-props\";\r\n  ['selectedItem', 'isOpen', 'inputValue', 'highlightedIndex'].forEach(function (propKey) {\r\n    if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\r\n      // eslint-disable-next-line no-console\r\n      console.error(\"downshift: A component has changed the controlled prop \\\"\" + propKey + \"\\\" to be uncontrolled. \" + warningDescription);\r\n    } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\r\n      // eslint-disable-next-line no-console\r\n      console.error(\"downshift: A component has changed the uncontrolled prop \\\"\" + propKey + \"\\\" to be controlled. \" + warningDescription);\r\n    }\r\n  });\r\n}\r\n\r\nexport default Downshift;\r\nexport { resetIdCounter };\r\n","/**\r\n * lodash (Custom Build) <https://lodash.com/>\r\n * Build: `lodash modularize exports=\"npm\" -o ./`\r\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\r\n * Released under MIT license <https://lodash.com/license>\r\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\r\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n */\r\n\r\n/** Used as the `TypeError` message for \"Functions\" methods. */\r\nvar FUNC_ERROR_TEXT = 'Expected a function';\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar NAN = 0 / 0;\r\n\r\n/** `Object#toString` result references. */\r\nvar symbolTag = '[object Symbol]';\r\n\r\n/** Used to match leading and trailing whitespace. */\r\nvar reTrim = /^\\s+|\\s+$/g;\r\n\r\n/** Used to detect bad signed hexadecimal string values. */\r\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\r\n\r\n/** Used to detect binary string values. */\r\nvar reIsBinary = /^0b[01]+$/i;\r\n\r\n/** Used to detect octal string values. */\r\nvar reIsOctal = /^0o[0-7]+$/i;\r\n\r\n/** Built-in method references without a dependency on `root`. */\r\nvar freeParseInt = parseInt;\r\n\r\n/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n\r\n/** Used as a reference to the global object. */\r\nvar root = freeGlobal || freeSelf || Function('return this')();\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar objectToString = objectProto.toString;\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeMax = Math.max,\r\n    nativeMin = Math.min;\r\n\r\n/**\r\n * Gets the timestamp of the number of milliseconds that have elapsed since\r\n * the Unix epoch (1 January 1970 00:00:00 UTC).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 2.4.0\r\n * @category Date\r\n * @returns {number} Returns the timestamp.\r\n * @example\r\n *\r\n * _.defer(function(stamp) {\r\n *   console.log(_.now() - stamp);\r\n * }, _.now());\r\n * // => Logs the number of milliseconds it took for the deferred invocation.\r\n */\r\nvar now = function() {\r\n  return root.Date.now();\r\n};\r\n\r\n/**\r\n * Creates a debounced function that delays invoking `func` until after `wait`\r\n * milliseconds have elapsed since the last time the debounced function was\r\n * invoked. The debounced function comes with a `cancel` method to cancel\r\n * delayed `func` invocations and a `flush` method to immediately invoke them.\r\n * Provide `options` to indicate whether `func` should be invoked on the\r\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\r\n * with the last arguments provided to the debounced function. Subsequent\r\n * calls to the debounced function return the result of the last `func`\r\n * invocation.\r\n *\r\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\r\n * invoked on the trailing edge of the timeout only if the debounced function\r\n * is invoked more than once during the `wait` timeout.\r\n *\r\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\r\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\r\n *\r\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\r\n * for details over the differences between `_.debounce` and `_.throttle`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Function\r\n * @param {Function} func The function to debounce.\r\n * @param {number} [wait=0] The number of milliseconds to delay.\r\n * @param {Object} [options={}] The options object.\r\n * @param {boolean} [options.leading=false]\r\n *  Specify invoking on the leading edge of the timeout.\r\n * @param {number} [options.maxWait]\r\n *  The maximum time `func` is allowed to be delayed before it's invoked.\r\n * @param {boolean} [options.trailing=true]\r\n *  Specify invoking on the trailing edge of the timeout.\r\n * @returns {Function} Returns the new debounced function.\r\n * @example\r\n *\r\n * // Avoid costly calculations while the window size is in flux.\r\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\r\n *\r\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\r\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\r\n *   'leading': true,\r\n *   'trailing': false\r\n * }));\r\n *\r\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\r\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\r\n * var source = new EventSource('/stream');\r\n * jQuery(source).on('message', debounced);\r\n *\r\n * // Cancel the trailing debounced invocation.\r\n * jQuery(window).on('popstate', debounced.cancel);\r\n */\r\nfunction debounce(func, wait, options) {\r\n  var lastArgs,\r\n      lastThis,\r\n      maxWait,\r\n      result,\r\n      timerId,\r\n      lastCallTime,\r\n      lastInvokeTime = 0,\r\n      leading = false,\r\n      maxing = false,\r\n      trailing = true;\r\n\r\n  if (typeof func != 'function') {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  wait = toNumber(wait) || 0;\r\n  if (isObject(options)) {\r\n    leading = !!options.leading;\r\n    maxing = 'maxWait' in options;\r\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\r\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n  }\r\n\r\n  function invokeFunc(time) {\r\n    var args = lastArgs,\r\n        thisArg = lastThis;\r\n\r\n    lastArgs = lastThis = undefined;\r\n    lastInvokeTime = time;\r\n    result = func.apply(thisArg, args);\r\n    return result;\r\n  }\r\n\r\n  function leadingEdge(time) {\r\n    // Reset any `maxWait` timer.\r\n    lastInvokeTime = time;\r\n    // Start the timer for the trailing edge.\r\n    timerId = setTimeout(timerExpired, wait);\r\n    // Invoke the leading edge.\r\n    return leading ? invokeFunc(time) : result;\r\n  }\r\n\r\n  function remainingWait(time) {\r\n    var timeSinceLastCall = time - lastCallTime,\r\n        timeSinceLastInvoke = time - lastInvokeTime,\r\n        result = wait - timeSinceLastCall;\r\n\r\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\r\n  }\r\n\r\n  function shouldInvoke(time) {\r\n    var timeSinceLastCall = time - lastCallTime,\r\n        timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n    // Either this is the first call, activity has stopped and we're at the\r\n    // trailing edge, the system time has gone backwards and we're treating\r\n    // it as the trailing edge, or we've hit the `maxWait` limit.\r\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\r\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\r\n  }\r\n\r\n  function timerExpired() {\r\n    var time = now();\r\n    if (shouldInvoke(time)) {\r\n      return trailingEdge(time);\r\n    }\r\n    // Restart the timer.\r\n    timerId = setTimeout(timerExpired, remainingWait(time));\r\n  }\r\n\r\n  function trailingEdge(time) {\r\n    timerId = undefined;\r\n\r\n    // Only invoke if we have `lastArgs` which means `func` has been\r\n    // debounced at least once.\r\n    if (trailing && lastArgs) {\r\n      return invokeFunc(time);\r\n    }\r\n    lastArgs = lastThis = undefined;\r\n    return result;\r\n  }\r\n\r\n  function cancel() {\r\n    if (timerId !== undefined) {\r\n      clearTimeout(timerId);\r\n    }\r\n    lastInvokeTime = 0;\r\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n  }\r\n\r\n  function flush() {\r\n    return timerId === undefined ? result : trailingEdge(now());\r\n  }\r\n\r\n  function debounced() {\r\n    var time = now(),\r\n        isInvoking = shouldInvoke(time);\r\n\r\n    lastArgs = arguments;\r\n    lastThis = this;\r\n    lastCallTime = time;\r\n\r\n    if (isInvoking) {\r\n      if (timerId === undefined) {\r\n        return leadingEdge(lastCallTime);\r\n      }\r\n      if (maxing) {\r\n        // Handle invocations in a tight loop.\r\n        timerId = setTimeout(timerExpired, wait);\r\n        return invokeFunc(lastCallTime);\r\n      }\r\n    }\r\n    if (timerId === undefined) {\r\n      timerId = setTimeout(timerExpired, wait);\r\n    }\r\n    return result;\r\n  }\r\n  debounced.cancel = cancel;\r\n  debounced.flush = flush;\r\n  return debounced;\r\n}\r\n\r\n/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * _.isObject({});\r\n * // => true\r\n *\r\n * _.isObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObject(_.noop);\r\n * // => true\r\n *\r\n * _.isObject(null);\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  var type = typeof value;\r\n  return !!value && (type == 'object' || type == 'function');\r\n}\r\n\r\n/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return !!value && typeof value == 'object';\r\n}\r\n\r\n/**\r\n * Checks if `value` is classified as a `Symbol` primitive or object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n *\r\n * _.isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * _.isSymbol('abc');\r\n * // => false\r\n */\r\nfunction isSymbol(value) {\r\n  return typeof value == 'symbol' ||\r\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\r\n}\r\n\r\n/**\r\n * Converts `value` to a number.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to process.\r\n * @returns {number} Returns the number.\r\n * @example\r\n *\r\n * _.toNumber(3.2);\r\n * // => 3.2\r\n *\r\n * _.toNumber(Number.MIN_VALUE);\r\n * // => 5e-324\r\n *\r\n * _.toNumber(Infinity);\r\n * // => Infinity\r\n *\r\n * _.toNumber('3.2');\r\n * // => 3.2\r\n */\r\nfunction toNumber(value) {\r\n  if (typeof value == 'number') {\r\n    return value;\r\n  }\r\n  if (isSymbol(value)) {\r\n    return NAN;\r\n  }\r\n  if (isObject(value)) {\r\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\r\n    value = isObject(other) ? (other + '') : other;\r\n  }\r\n  if (typeof value != 'string') {\r\n    return value === 0 ? value : +value;\r\n  }\r\n  value = value.replace(reTrim, '');\r\n  var isBinary = reIsBinary.test(value);\r\n  return (isBinary || reIsOctal.test(value))\r\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\r\n    : (reIsBadHex.test(value) ? NAN : +value);\r\n}\r\n\r\nmodule.exports = debounce;\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAQA;AAAA;AAUA;AAAA;AAAA;AAAA;AAEA;AAAA;AAaA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;AAZA;AACA;AAcA;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAIA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAGA;AAAA;AAMA;AAUA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACjCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACp/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;A","sourceRoot":""}